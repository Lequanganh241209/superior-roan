
import { NextResponse } from 'next/server';
import OpenAI from 'openai';

export const maxDuration = 60;

export async function POST(req: Request) {
  try {
    const { prompt, plan } = await req.json();

    if (!prompt || !plan) {
      return NextResponse.json({ error: "Missing prompt or plan" }, { status: 400 });
    }

    if (!process.env.OPENAI_API_KEY) {
         // Simulation Mode
         await new Promise(r => setTimeout(r, 2000));
         return NextResponse.json({
             files: [
                 { path: "README.md", content: `# ${prompt}\n\nGenerated by Supreme Orchestrator.` },
                 { path: "src/app/page.tsx", content: "export default function Home() { return <h1>Hello World</h1> }" }
             ]
         });
    }

    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    const systemPrompt = `
    You are an Elite Senior Full-Stack Architect and UI/UX Designer.
    Your mission is to generate a PRODUCTION-READY, DEPLOYABLE Next.js 14 Application based on the User's Prompt and the Architect's Plan.

    The goal is to rival "Lovable.dev" in quality:
    1.  **Visually Stunning**: Use modern UI patterns, beautiful gradients, glassmorphism, and responsive layouts.
    2.  **Fully Functional**: The app must be runnable immediately after deployment.
    3.  **Component-Driven**: Break down the UI into small, reusable components in \`src/components\`.

    OUTPUT FORMAT:
    Return a JSON object with a single "files" array. Each item must have:
    - "path": The relative file path (e.g., "package.json", "src/app/page.tsx").
    - "content": The COMPLETE source code for that file.

    MANDATORY FILE STRUCTURE (You MUST generate ALL of these):
    
    1.  **Configuration Files** (Use standard Next.js 14 + Tailwind defaults):
        - \`package.json\`: Include dependencies: next, react, react-dom, lucide-react, framer-motion, clsx, tailwind-merge, tailwindcss-animate.
        - \`tsconfig.json\`
        - \`next.config.js\`
        - \`tailwind.config.ts\`: Configure with CSS variables for colors (shadcn-like).
        - \`postcss.config.js\`
        - \`.gitignore\`
        - \`next-env.d.ts\`

    2.  **Core App Files**:
        - \`src/app/layout.tsx\`: Include Inter font, Metadata, and global providers.
        - \`src/app/globals.css\`: Define comprehensive Tailwind CSS variables (@layer base) for a dark-mode first theme (primary, secondary, accent, background, foreground).
        - \`src/app/page.tsx\`: The main landing page. MAKE IT IMPRESSIVE. Use Hero sections, Feature grids, and Call-to-Actions.
    
    3.  **Components** (\`src/components/...\`):
        - Create a \`src/components/ui\` folder for base elements (Button, Card, Input) using standard patterns.
        - Create feature-specific components (e.g., \`src/components/landing/Hero.tsx\`).
        - Use \`lucide-react\` for icons.
        - Use \`framer-motion\` for subtle entrance animations.

    4.  **Database**:
        - \`supabase/migrations/20240101_init.sql\`: Use the SQL provided in the Plan.

    GUIDELINES:
    - **Code Quality**: Strict TypeScript, no "any" types if possible.
    - **Styling**: Use \`clsx\` and \`tailwind-merge\` for dynamic classes.
    - **Theme**: Default to a sophisticated DARK MODE.
    - **Content**: Use the User Prompt to infer specific text, titles, and features.

    GENERATE A COMPLETE, WORKING REPOSITORY. DO NOT HALLUCINATE MISSING FILES.
    `;

    const userMessage = `
    Prompt: ${prompt}
    
    Plan SQL:
    ${plan.sql}
    
    Plan Description:
    ${plan.description}
    `;

    const completion = await openai.chat.completions.create({
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userMessage }
      ],
      model: "gpt-4o",
      response_format: { type: "json_object" },
    });

    const content = completion.choices[0].message.content;
    if (!content) throw new Error("No content from OpenAI");

    const result = JSON.parse(content);

    return NextResponse.json({ files: result.files });

  } catch (error: any) {
    console.error("Codegen Error:", error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}
